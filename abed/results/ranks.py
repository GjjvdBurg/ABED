"""
Functions for generating fractional ranks

"""

import datetime
import os

from abed import settings
from abed.utils import info

def get_ranks(x):
    """
        Get ranks for a vector. This function assumes lower is better, so high 
        numbers get a high rank. You can invert it with: [len(x) - t + 1 for t 
        in ranks]

        >>> x = [7, 0.1, 0.5, 0.1, 10, 100, 200]
        >>> get_ranks(x)
        [4.0, 1.5, 3.0, 1.5, 5.0, 6.0, 7.0]
    """
    l = len(x)
    r = 1
    ranks = [0]*l
    while not all([k is None for k in x]):
        m = min([k for k in x if not k is None])
        idx = [1 if k == m else 0 for k in x]
        s = sum(idx)
        ranks = [r + (s-1)/2.0 if idx[k] else ranks[k] for k in range(l)]
        r += s
        x = [None if idx[k] else x[k] for k in range(l)]
    return ranks

def make_rank_table(table, higher_better):
    ranktable = []
    for row in table:
        data = row[1:]
        ranks = get_ranks(data)
        if higher_better:
            ranks = [len(ranks) - t + 1 for t in ranks]
        rankrow = [row[0]] + ranks
        ranktable.append(rankrow)
    return ranktable

def write_ranktable(tabletxt, label, metricname=None):
    if metricname is None:
        fname = '%s%sABED_%s_ranks.txt' % (settings.OUTPUT_DIR, os.sep, label)
    else:
        fname = '%s%sABED_%s_%s_ranks.txt' % (settings.OUTPUT_DIR, os.sep, 
                label, metricname)
    now = datetime.datetime.now()
    with open(fname, 'w') as fid:
        fid.write("%% Result file generated by ABED at %s\n" % 
                now.strftime('%c'))
        fid.write("%% Table for label: %s\n")
        fid.write("% Showing: ranks\n")
        if not metricname is None:
            fid.write("%% Metric: %s\n\n" % metricname)
        fid.write(tabletxt)
    info("Created output file: %s" % fname)
